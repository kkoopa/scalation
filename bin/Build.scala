
//::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
/** @author  John Miller
 *  @version 1.1
 *  @date    Tue Aug  6 18:09:32 EDT 2013
 *  @see     LICENSE (MIT style license file).
 *
 *  Recommended to use the Simple Build Tool (sbt) instead.
 */

//::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
/** The `Build` object is used to build the scalation Scala-based Simulation System.
 *  Comment out lines using // for customized builds.  To build the complete
 *  scalation system, type the following two commands:
 *  > scalac Build.scala
 *  > scala Build
 *  Check the file called 'errorlog' for errors generated by any of the
 *  build functions.  Note, this Build object is just a backup for the
 *  Simple Build Tool (sbt).
 */
object Build extends App
{
    private val BASE_DIR   = ".."
    private val source_dir = BASE_DIR + "src/main/scala"
    private val class_dir  = BASE_DIR + "classes"
    private val doc_dir    = BASE_DIR + "doc"
    private val runsys     = Runtime.getRuntime ()
    private var command    = Array ("")

    /** The packages making up scalation -- comment out (//) for selective builds
     */
    private val packages = Array ("scalation/util",
                                  "scalation/scala2d",
                                  "scalation/scala3d",
                                  "scalation/math",
                                  "scalation/linalgebra",
                                  "scalation/linalgebra/gen",
                                  "scalation/linalgebra/par",
                                  "scalation/calculus",
                                  "scalation/random",
                                  "scalation/plot",
                                  "scalation/stat",
                                  "scalation/model",
                                  "scalation/animation",
                                  "scalation/minima",
                                  "scalation/maxima",
                                  "scalation/analytics",
                                  "scalation/analytics/par",
                                  "scalation/graphalytics",
                                  "scalation/metamodel",
                                  "scalation/queueingnet",
                                  "scalation/dynamics",
                                  "scalation/dynamics_pde",
                                  "scalation/physics",
                                  "scalation/activity",
                                  "scalation/event",
                                  "scalation/process",
                                  "scalation/state",
                                  "scalation/tableau")

    /** The example apps/models -- comment out (//) for selective builds
     */
    private val apps = Array ("apps/activity",
                              "apps/analytics",
                              "apps/dynamics",
                              "apps/event",
                              "apps/game",
                              "apps/montecarlo",
                              "apps/optimization",
                              "apps/process",
                              "apps/simopt",
                              "apps/state",
                              "apps/tableau")

    //::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    /** Clear the error log.  The errorlog file shows errors generated any of the
     *  build functions shown below.
     */
    def clearlog
    {
        command = Array ("/bin/sh", "-c", "/bin/date > errorlog")
        runsys.exec (command)
        println (command.deep)
    } // clearlog

    //::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    /** Start a clean build by removing all old .class files.
     */
    def clean
    {
        for (p <- packages) {
            command = Array ("/bin/sh", "-c", "/bin/rm " + class_dir + "/" + p + "/*.class")
            runsys.exec(command)
            println (command.deep)
        } // for
    } // clean

    //::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    /** Compile the source files (.scala) for all the packages in scalation.
     */
    def compile
    {
        for (p <- packages) {
            command = Array ("/bin/sh", "-c", "scalac -cp " + class_dir + " -d " + class_dir + " " +
                             source_dir + "/" + p + "/*.scala" + " 2>> errorlog")
            val cmd = Array ("/bin/sh", "-c", "echo ----- " + p + " >> errorlog")
            println (cmd.deep)
            val proccmd = runsys.exec (cmd)
            proccmd.waitFor ()
            val proc = runsys.exec (command)
            proc.waitFor ()
            println (command.deep)
        } // for
    } // compile

    //::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    /** Compile the source files (.scala) for all the apps.
     */
    def compileApps
    {
        for (p <- apps) {
            command = Array ("/bin/sh", "-c", "scalac -cp " + class_dir + " -d " + class_dir + " " +
                             source_dir + "/" + p + "/*.scala" + " 2>> errorlog")
            val cmd = Array ("/bin/sh", "-c", "echo ----- " + p + " >> errorlog")
            println (cmd.deep)
            val proccmd = runsys.exec (cmd)
            proccmd.waitFor ()
            val proc = runsys.exec (command)
            proc.waitFor ()
            println (command.deep)
        } // for
    } // compileApps

   //::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    /** Print how to generate scaladoc files for all the scalation packages.
     *  FIX: run scaladoc programmatically
     *  @see http://www.scala-lang.org/docu/files/tools/scaladoc.html
     */
    def doc
    {
        val _J    = " -J-mx1024m"
        val _cp   = " -classpath " + class_dir
        val files = " ../" + source_dir + "/*/*/*.scala" + " ../" + source_dir +  "/*/*/*/*.scala"
        println ("\n***To generate scaladoc documentation execute the following two commands:")
        println ("$ " + "cd doc")
        println ("$ " + "scaladoc" + _J + _cp + files)
    } // doc

    //::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    /** Generate index.html for browsing the source code.
     */
    def genIndexHtml
    {
        command = Array ("/bin/sh", "-c", "scala -cp bin GenIndexHtml 2>> errorlog")
        val proc = runsys.exec (command)
        proc.waitFor ()
        println (command.deep)
    } // genIndexHtml

    // select build functions by moving the comment delimiters (/***, ***/)
    clearlog
    clean
    compile
    compileApps
    genIndexHtml
    doc
/***
***/

} // Build

